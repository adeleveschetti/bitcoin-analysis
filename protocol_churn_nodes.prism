ctmc


const k;
const T=k*600;

// rates
const double rb=10/126 ;
const double mR = 1/600;
const double lR = 1-mR;

// hashing powers
const double hR = 0.2;
const double hR1 = 0.2;
const double hR2 = 0.2;
const double hR3 = 0.2;
const double hR4 = 0.2;

const int N = 100;

// state variables
const int Mine = 0;
const int Winner = 1;
const int Lost = 2;
const int Move = 3;
const int Add = 4;


module Controller
  Controller_STATE : [0..3] init 0;

  [sleep] (Controller_STATE = 0) -> r_00 : Controller_STATE' = 1;
  [awake] (Controller_STATE = 1) -> r_01 : Controller_STATE' = 2;
  [sleep] (Controller_STATE = 2) -> r_02 : Controller_STATE' = 3;

endmodule

module Controller1
  Controller1_STATE : [0..4] init 0;

  [sleep1] (Controller1_STATE = 0) -> r_10 : Controller1_STATE' = 1;
  [awake1] (Controller1_STATE = 1) -> r_11 : Controller1_STATE' = 2;
  [sleep1] (Controller1_STATE = 2) -> r_12 : Controller1_STATE' = 3;
  [awake1] (Controller1_STATE = 3) -> r_13 : Controller1_STATE' = 4;

endmodule

module Controller2
  Controller2_STATE : [0..4] init 0;

  [sleep2] (Controller2_STATE = 0) -> r_20 : Controller2_STATE' = 1;
  [awake2] (Controller2_STATE = 1) -> r_21 : Controller2_STATE' = 2;
  [sleep2] (Controller2_STATE = 2) -> r_22 : Controller2_STATE' = 3;
  [awake2] (Controller2_STATE = 3) -> r_23 : Controller2_STATE' = 4;

endmodule

module Controller3
  Controller3_STATE : [0..5] init 0;

  [sleep3] (Controller3_STATE = 0) -> r_30 : Controller3_STATE' = 1;
  [awake3] (Controller3_STATE = 1) -> r_31 : Controller3_STATE' = 2;
  [sleep3] (Controller3_STATE = 2) -> r_32 : Controller3_STATE' = 3;
  [awake3] (Controller3_STATE = 3) -> r_33 : Controller3_STATE' = 4;
  [sleep3] (Controller3_STATE = 4) -> r_34 : Controller3_STATE' = 5;

endmodule

module Controller4
  Controller4_STATE : [0..5] init 0;

  [sleep4] (Controller4_STATE = 0) -> r_40 : Controller4_STATE' = 1;
  [awake4] (Controller4_STATE = 1) -> r_41 : Controller4_STATE' = 2;
  [sleep4] (Controller4_STATE = 2) -> r_42 : Controller4_STATE' = 3;
  [awake4] (Controller4_STATE = 3) -> r_43 : Controller4_STATE' = 4;
  [sleep4] (Controller4_STATE = 4) -> r_44 : Controller4_STATE' = 5;

endmodule

module Hasher

  Hasher_STATE : [0..1] init 0;

	[win] (Hasher_STATE=0) -> mR : (Hasher_STATE'=0);
	[lose] (Hasher_STATE=0) -> lR : (Hasher_STATE'=0);

endmodule

module Hasher1

  Hasher1_STATE : [0..1] init 0;

	[win1] (Hasher1_STATE=0) -> mR : (Hasher1_STATE'=0);
	[lose1] (Hasher1_STATE=0) -> lR : (Hasher1_STATE'=0);

endmodule

module Hasher2

  Hasher2_STATE : [0..1] init 0;

	[win2] (Hasher2_STATE=0) -> mR : (Hasher2_STATE'=0);
	[lose2] (Hasher2_STATE=0) -> lR : (Hasher2_STATE'=0);

endmodule

module Hasher3

  Hasher3_STATE : [0..1] init 0;

	[win3] (Hasher3_STATE=0) -> mR : (Hasher3_STATE'=0);
	[lose3] (Hasher3_STATE=0) -> lR : (Hasher3_STATE'=0);

endmodule

module Hasher4

  Hasher4_STATE : [0..1] init 0;

	[win4] (Hasher4_STATE=0) -> mR : (Hasher4_STATE'=0);
	[lose4] (Hasher4_STATE=0) -> lR : (Hasher4_STATE'=0);

endmodule

module M

	M_STATE : [Mine..Add] init Mine;
	b : block {m,0;genesis,0};
	B : blockchain [{genesis,0;genesis,0}];
	c : [0..N] init 0;
	setMiner : list [];
	lenB : [0..N] init 0; // length of the set "setMiner"
	tmp : [0..1] init 0;
  canAdd : [0..1] init 0; // auxiliary variable which stores if the block can be added (1) or not (0)

  [sleep] (M_STATE = Mine) -> 1 : (M_STATE'=Sleep);
	[win] (M_STATE = Mine) -> hR : (M_STATE'=Winner)&(b'=B+c)&(c'=c+1);
  [lose] (M_STATE = Mine) -> hR : (M_STATE'=Lost);
	[addBlock] (M_STATE = Winner) -> 1 : (B'=B+b)&(M_STATE'=Mine);
	[] (M_STATE = Lost)&(len>0)-> 1 : (b'=b+set)&(M_STATE'=Move);
	[] (M_STATE = Lost)&(lenB>0)   ->  1 : (M_STATE'=Add)&(b'=b+setMiner);
  [] (M_STATE = Lost)&(len=0)   ->  1 : (M_STATE'=Mine);
  [] (M_STATE = Update)&(len>0) -> 1 : (b'=b+set)&(M_STATE'=MoveUpdate);
  [] (M_STATE = Update)&(len>0) -> 1 : (M_STATE'=Mine);
  [removeBlock] (M_STATE=Move) -> 1 : (setMiner'=setMiner+b)&(lenB'=lenB+1)&(M_STATE'=Mine);
  [removeBlock] (M_STATE=MoveUpdate) -> 1 : (setMiner'=setMiner+b)&(lenB'=lenB+1)&(M_STATE'=Update);
	[] (M_STATE=Add) -> 1 : (canAdd'=b+B)&(tmp'=1);
	[] (M_STATE=Add)&(tmp=1)&(canAdd=1) -> 1 : (B'=B+b)&(setMiner'=setMiner-b)&(M_STATE'=Mine)&(tmp'=0)&(lenB'=lenB-1);
	[] (M_STATE=Add)&(tmp=1)&(canAdd=0) -> 1 : (tmp'=0)&(M_STATE'=Mine);
  [awake] (M_STATE = Sleep) -> 1 : (M_STATE'=Update);

endmodule

module M1

	M1_STATE : [Mine..Add] init Mine;
	b1 : block {m1,0;genesis,0};
	B1 : blockchain [{genesis,0;genesis,0}];
	c1 : [0..N] init 0;
	setMiner1 : list [];
	lenB1 : [0..N] init 0; // length of the set "setMiner"
	tmp1 : [0..1] init 0;
  canAdd1 : [0..1] init 0; // auxiliary variable which stores if the block can be added (1) or not (0)

  [sleep1] (M1_STATE = Mine) -> 1 : (M1_STATE'=Sleep);
	[win1] (M1_STATE = Mine) -> hR1 : (M1_STATE'=Winner)&(b1'=B1+c1)&(c1'=c1+1);
  [lose1] (M1_STATE = Mine) -> hR1 : (M1_STATE'=Lost);
	[addBlock1] (M1_STATE = Winner) -> 1 : (B1'=B1+b1)&(M1_STATE'=Mine);
	[] (M1_STATE = Lost)&(len1>0)-> 1 : (b1'=b1+set1)&(M1_STATE'=Move);
	[] (M1_STATE = Lost)&(lenB1>0)   ->  1 : (M1_STATE'=Add)&(b1'=b1+setMiner1);
  [] (M1_STATE = Lost)&(len1=0)   ->  1 : (M1_STATE'=Mine);
  [] (M1_STATE = Update)&(len1>0) -> 1 : (b1'=b1+set1)&(M1_STATE'=MoveUpdate);
  [] (M1_STATE = Update)&(len1>0) -> 1 : (M1_STATE'=Mine);
  [removeBlock1] (M1_STATE=Move) -> 1 : (setMiner1'=setMiner1+b1)&(lenB1'=lenB1+1)&(M1_STATE'=Mine);
  [removeBlock1] (M1_STATE=MoveUpdate) -> 1 : (setMiner1'=setMiner1+b1)&(lenB1'=lenB1+1)&(M1_STATE'=Update);
	[] (M1_STATE=Add) -> 1 : (canAdd1'=b1+B1)&(tmp1'=1);
	[] (M1_STATE=Add)&(tmp1=1)&(canAdd1=1) -> 1 : (B1'=B1+b1)&(setMiner1'=setMiner1-b1)&(M1_STATE'=Mine)&(tmp1'=0)&(lenB1'=lenB1-1);
	[] (M1_STATE=Add)&(tmp1=1)&(canAdd1=0) -> 1 : (tmp1'=0)&(M1_STATE'=Mine);
  [awake1] (M1_STATE = Sleep) -> 1 : (M1_STATE'=Update);

endmodule


module M2

	M2_STATE : [Mine..Add] init Mine;
	b2 : block {m2,0;genesis,0};
	B2 : blockchain [{genesis,0;genesis,0}];
	c2 : [0..N] init 0;
	setMiner2 : list [];
	lenB2 : [0..N] init 0; // length of the set "setMiner"
	tmp2 : [0..1] init 0;
  canAdd2 : [0..1] init 0; // auxiliary variable which stores if the block can be added (1) or not (0)

  [sleep2] (M2_STATE = Mine) -> 1 : (M2_STATE'=Sleep);
  [win2] (M2_STATE = Mine) -> hR2 : (M2_STATE'=Winner)&(b2'=B2+c2)&(c2'=c2+1);
  [lose2] (M2_STATE = Mine) -> hR2 : (M2_STATE'=Lost);
  [addBlock2] (M2_STATE = Winner) -> 1 : (B2'=B2+b2)&(M2_STATE'=Mine);
  [] (M2_STATE = Lost)&(len2>0)-> 1 : (b2'=b2+set2)&(M2_STATE'=Move);
  [] (M2_STATE = Lost)&(lenB2>0)   ->  1 : (M2_STATE'=Add)&(b2'=b2+setMiner2);
  [] (M2_STATE = Lost)&(len2=0)   ->  1 : (M2_STATE'=Mine);
  [] (M2_STATE = Update)&(len2>0) -> 1 : (b2'=b2+set2)&(M2_STATE'=MoveUpdate);
  [] (M2_STATE = Update)&(len2>0) -> 1 : (M2_STATE'=Mine);
  [removeBlock2] (M2_STATE=Move) -> 1 : (setMiner2'=setMiner2+b2)&(lenB2'=lenB2+1)&(M2_STATE'=Mine);
  [removeBlock2] (M2_STATE=MoveUpdate) -> 1 : (setMiner2'=setMiner2+b2)&(lenB2'=lenB2+1)&(M2_STATE'=Update);
  [] (M2_STATE=Add) -> 1 : (canAdd2'=b2+B2)&(tmp2'=1);
  [] (M2_STATE=Add)&(tmp2=1)&(canAdd2=1) -> 1 : (B2'=B2+b2)&(setMiner2'=setMiner2-b2)&(M2_STATE'=Mine)&(tmp2'=0)&(lenB2'=lenB2-1);
  [] (M2_STATE=Add)&(tmp2=1)&(canAdd2=0) -> 1 : (tmp2'=0)&(M2_STATE'=Mine);
  [awake2] (M2_STATE = Sleep) -> 1 : (M2_STATE'=Update);

endmodule


module M3

	M3_STATE : [Mine..Add] init Mine;
	b3 : block {m3,0;genesis,0};
	B3 : blockchain [{genesis,0;genesis,0}];
	c3 : [0..N] init 0;
	setMiner3 : list [];
	lenB3 : [0..N] init 0; // length of the set "setMiner"
	tmp3 : [0..1] init 0;
  canAdd3 : [0..1] init 0; // auxiliary variable which stores if the block can be added (1) or not (0)

  [sleep3] (M3_STATE = Mine) -> 1 : (M3_STATE'=Sleep);
  [win3] (M3_STATE = Mine) -> hR3 : (M3_STATE'=Winner)&(b3'=B3+c3)&(c3'=c3+1);
  [lose3] (M3_STATE = Mine) -> hR3 : (M3_STATE'=Lost);
  [addBlock3] (M3_STATE = Winner) -> 1 : (B3'=B3+b3)&(M3_STATE'=Mine);
  [] (M3_STATE = Lost)&(len3>0)-> 1 : (b3'=b3+set3)&(M3_STATE'=Move);
  [] (M3_STATE = Lost)&(lenB3>0)   ->  1 : (M3_STATE'=Add)&(b3'=b3+setMiner3);
  [] (M3_STATE = Lost)&(len3=0)   ->  1 : (M3_STATE'=Mine);
  [] (M3_STATE = Update)&(len3>0) -> 1 : (b3'=b3+set3)&(M3_STATE'=MoveUpdate);
  [] (M3_STATE = Update)&(len3>0) -> 1 : (M3_STATE'=Mine);
  [removeBlock3] (M3_STATE=Move) -> 1 : (setMiner3'=setMiner3+b3)&(lenB3'=lenB3+1)&(M3_STATE'=Mine);
  [removeBlock3] (M3_STATE=MoveUpdate) -> 1 : (setMiner3'=setMiner3+b3)&(lenB3'=lenB3+1)&(M3_STATE'=Update);
  [] (M3_STATE=Add) -> 1 : (canAdd3'=b3+B3)&(tmp3'=1);
  [] (M3_STATE=Add)&(tmp3=1)&(canAdd3=1) -> 1 : (B3'=B3+b3)&(setMiner3'=setMiner3-b3)&(M3_STATE'=Mine)&(tmp3'=0)&(lenB3'=lenB3-1);
  [] (M3_STATE=Add)&(tmp3=1)&(canAdd3=0) -> 1 : (tmp3'=0)&(M3_STATE'=Mine);
  [awake3] (M3_STATE = Sleep) -> 1 : (M3_STATE'=Update);

endmodule


module M4

	M4_STATE : [Mine..Add] init Mine;
	b4 : block {m4,0;genesis,0};
	B4 : blockchain [{genesis,0;genesis,0}];
	c4 : [0..N] init 0;
	setMiner4 : list [];
	lenB4 : [0..N] init 0; // length of the set "setMiner"
	tmp4 : [0..1] init 0;
  canAdd4 : [0..1] init 0; // auxiliary variable which stores if the block can be added (1) or not (0)

  [sleep4] (M4_STATE = Mine) -> 1 : (M4_STATE'=Sleep);
  [win4] (M4_STATE = Mine) -> hR4 : (M4_STATE'=Winner)&(b4'=B4+c4)&(c4'=c4+1);
  [lose4] (M4_STATE = Mine) -> hR4 : (M4_STATE'=Lost);
  [addBlock4] (M4_STATE = Winner) -> 1 : (B4'=B4+b4)&(M4_STATE'=Mine);
  [] (M4_STATE = Lost)&(len4>0)-> 1 : (b4'=b4+set4)&(M4_STATE'=Move);
  [] (M4_STATE = Lost)&(lenB4>0)   ->  1 : (M4_STATE'=Add)&(b4'=b4+setMiner4);
  [] (M4_STATE = Lost)&(len4=0)   ->  1 : (M4_STATE'=Mine);
  [] (M4_STATE = Update)&(len4>0) -> 1 : (b4'=b4+set4)&(M4_STATE'=MoveUpdate);
  [] (M4_STATE = Update)&(len4>0) -> 1 : (M4_STATE'=Mine);
  [removeBlock4] (M4_STATE=Move) -> 1 : (setMiner4'=setMiner4+b4)&(lenB4'=lenB4+1)&(M4_STATE'=Mine);
  [removeBlock4] (M4_STATE=MoveUpdate) -> 1 : (setMiner4'=setMiner4+b4)&(lenB4'=lenB4+1)&(M4_STATE'=Update);
  [] (M4_STATE=Add) -> 1 : (canAdd4'=b4+B4)&(tmp4'=1);
  [] (M4_STATE=Add)&(tmp4=1)&(canAdd4=1) -> 1 : (B4'=B4+b4)&(setMiner4'=setMiner4-b4)&(M4_STATE'=Mine)&(tmp4'=0)&(lenB4'=lenB4-1);
  [] (M4_STATE=Add)&(tmp4=1)&(canAdd4=0) -> 1 : (tmp4'=0)&(M4_STATE'=Mine);
  [awake4] (M4_STATE = Sleep) -> 1 : (M4_STATE'=Update);

endmodule


module Network

	Network_STATE : [0..2] init 0;

	set : list [];
	set1 : list [];
	set2 : list [];
	set3 : list [];
	set4 : list [];
	len : [0..N] init 0;
	len1 : [0..N] init 0;
	len2 : [0..N] init 0;
	len3 : [0..N] init 0;
	len4 : [0..N] init 0;

  [addBlock] (M_STATE=Winner)  -> rb : (set1'=set1+b)&(set2'=set2+b)&(set3'=set3+b)&(set4'=set4+b)&(len2'=len2+1)&(len1'=len1+1)&(len3'=len3+1)&(len4'=len4+1);
	[removeBlock] (M_STATE=Lost) | (M_STATE=MoveUpdate) -> 1 : (set'=set-b)&(len'=len-1);
	[addBlock1] (M1_STATE=Winner) -> rb : (set'=set+b1)&(set2'=set2+b1)&(set3'=set3+b1)&(set4'=set4+b1)&(len3'=len3+1)&(len4'=len4+1)&(len2'=len2+1)&(len'=len+1);
	[removeBlock1] (M1_STATE=Lost) | (M1_STATE=MoveUpdate) -> 1 : (set1'=set1-b1)&(len1'=len1-1);
	[addBlock2] (M2_STATE=Winner)   -> rb : (set'=set+b2)&(set1'=set1+b2)&(set3'=set3+b2)&(set4'=set4+b2)&(len3'=len3+1)&(len4'=len4+1)&(len1'=len1+1)&(len'=len+1);
	[removeBlock2] (M2_STATE=Lost) | (M2_STATE=MoveUpdate) -> 1 : (set2'=set2-b2)&(len2'=len2-1);
	[addBlock3] (M3_STATE=Winner)   -> rb : (set'=set+b3)&(set1'=bag1+b3)&(set2'=set3+b3)&(set4'=set4+b3)&(len2'=len3+1)&(len4'=len4+1)&(len1'=len1+1)&(len'=len+1);
	[removeBlock3] (M3_STATE=Lost) | (M3_STATE=MoveUpdate) -> 1 : (set3'=set3-b3)&(len3'=len3-1);
	[addBlock4] (M4_STATE=Winner)   -> rb : (set'=set+b4)&(set1'=bag1+b4)&(set3'=set3+b4)&(set2'=set4+b4)&(len3'=len3+1)&(len2'=len2+1)&(len1'=len1+1)&(len'=len+1);
	[removeBlock4] (M4_STATE=Lost) | (M4_STATE=MoveUpdate) -> 1 : (set4'=set4-b4)&(len4'=len4-1);

endmodule

module Global

	diff : [0..N] init 0;
	diff1 : [0..N] init 0;
	diff2 : [0..N] init 0;
	diff3 : [0..N] init 0;
	diff4 : [0..N] init 0;

	[] (M_STATE = Add) -> 1 : (diff'=max(B-B1,B-B2,B-B3,B-B4));
	[] (M1_STATE = Add) -> 1 : (diff1'=max(B1-B,B1-B2,B1-B3,B1-B4));
	[] (M2_STATE = Add) -> 1 : (diff2'=max(B2-B1,B2-B,B2-B3,B2-B4));
	[] (M3_STATE = Add) -> 1 : (diff3'=max(B3-B1,B3-B2,B3-B,B3-B4));
	[] (M4_STATE = Add) -> 1 : (diff4'=max(B4-B1,B4-B2,B4-B3,B4-B));

endmodule

label "mining" = M_STATE = Winner | M1_STATE = Winner | M2_STATE = Winner |  M3_STATE = Winner |  M4_STATE = Winner;
label "mining0" = M_STATE = Winner;
label "mining1" = M1_STATE = Winner;
label "mining2" = M2_STATE = Winner;
label "mining3" = M3_STATE = Winner;
label "mining4" = M4_STATE = Winner;
